# 变量章节学习

- 变量的声明方式为：let关键字 变量名;
- 在rust语言中变量中的值默认是不可变的（类似于常量中的不可变特点）；
- 如果需要变量的值在之后可以进行改变需要在let关键字后面 加上mut关键字。  
    可变变量格式为:let mut 变量名称;
- 变量可以在声明时就对其进行初始化并指定初始值。
    格式为：let关键字 变量名[： 可选数据类型注解]=值。
- rust程序可以在编译时通过值类型进行推导出变量所使用的类型，但是当一个可能出现多种可能类型的值时或者说是不确定类型的值时编译器则不能推测出本次赋值应该使用什么类型的值才合适 类似于parse()返回的是多种可能的值。
  ***注意声明***一个指定类型的变量后要在后面进行使用的话必须要对其进行初始化，因为***在rust中变量并没有其他语言中的默认值***。
*** 变量与常量的区别：***
变量的使用只局限于自己的作用域。
# 数据类型章节学习

- RUST内置数据类型分为标量数据类型和复合数据类型两种（存在于栈上）。
  - 标量类型：
    - 整型：有符号整型:（i8、i16、i32、i64、isize）和无符号整型(u8、u16、u32、u64、usize)长度分别为:(8bit、16bit、32bit、64bit、arch)。如果没有为一个整型值声明类型则rust默认为i32有符号32位整型。
    - 浮点型:f32、f64分别代表单精度浮点型和双精度浮点型。如果没有为一个浮点型值声明类型则rust默认为f64双精度浮点型。
    ***字面值：***字面值是允许使用数据类型后缀的。例如：53u8（代表整数53是一个无符号的8位整型）；除了支持字面值类型后缀以外还支持可视化分割符。例如：1_000中间的下划线就是可视化分隔符，可以方便人们一眼认出该数字为1000。
    - 布尔型:true真 false假 *注意：rust并不会将一个非boolean类型自动转换为一个boolean类型。*
    - 字符char型:以单引号包裹的utf-8的unicode字符；因为支持unicode字符编码所以可以使用的值很多很多包括很多自然语言。例：中文汉字、日文、韩语等等。
  - 复合类型：
    - 元组：元组是一个包含多个数据类型值的组合。元组使用圆括号()进行包裹值，值与值之间使用逗号,分割。
      - 元组的元素访问方式：
        - 可以通过模式匹配的方式将元组拆分成元素个数的份数，并未每个元素绑定一个变量名称，再访问该变量即可。
        - 也可以通过.操作符进行访问索引指向的元素。例如：元组名.元素的索引。
    - 数组：与元组不同的是数组是一个单一数据类型值的组合。在rust中数组一旦声明则长度不可变。数组使用中括号[]进行包裹值，值与值之间使用逗号,分割。
      - 数组的元素访问方式：与其他编程语言一样通过数组名[索引]的方式进行访问。
        - 当访问一个数组不存在的下标元素时（也就是所谓的数组下标溢出）rust在编译时并不会出现编译错误而是在运行时才发生错误。
    ***元组和数组的每个值都拥有一个索引下标；下标从0开始。***
# rust函数学习
- 函数的声明:
  - rust函数使用***fn关键字 函数名([形参名1: 数据类型, 形参名2: 数据类型,可选形参列表])->数据类型{}***进行声明一个函数。括号开始与括号结束的中间部分都为该函数的函数体。例如：fn a(x: i32) -> i32{println!("x：", x)}
    - 注意：与java一样在rust中必须声明每个形参的数据类型。
  - rust函数名方式是snake case命名规范的命名规则。规则为：所有的字母都为小写，单词与单词之间以下划线_进行分隔。
- 函数的调用方式:与其他编程语言一样rust使用函数名([实参列表])的方式对函数进行调用。
  ***注意：rust并不关心函数是在何处进行定义的，只要该函数有定义则可以调用。***
- 表达式与语句：
  - 语句：是指执行某项操作单不返回值。
  - 表达式：执行某项操作并返回值。
  ***注意：***
    ***1.声明一个函数是一个语句，而调用一个函数或者宏则是一个表达式。***
    ***2.返回值：函数总是会返回函数体中最后一个表达式的值***
# 注释：

  - //行注释
  - /* */块注释

# 条件控制:

1. 
if boolean条件表达式 {

}
2. 
if boolean条件表达式 {

}else{

}
3. 
if 条件表达式 {

}else if boolean条件表达式{

}else{

}
# 循环
  rust提供了loop while for三种循环类型。
  - loop{ }循环是代表创建了一个无限执行循环体中内容的循环。
  - while 布尔表达式{ }当布尔表达式为真时则执行该循环体中的内容。
  - for in { }
# String字符串
- String字面量类型:在编译时就可得到该字符串变量的值，编译器会将其编译进二进制可执行文件中，正因为这样也导致了其变量的不可变性。
- String::from("");通过String的from函数可以在运行时向操作系统请求内存并存入一个字符串类型，因为该方法需要在运行时才会调用而且还可对其进行改变，所以我们可以将其存放在一个可变变量中。
  *注意：为了支持字符串可变性而不导致在请求较大内存却存入较小字符串值后内存的浪费，所以在字符串处理完成以后需要对其尚未使用的内存需要对操作系统进行返还。常见编程语言通常采用的方法有自动垃圾回收GC gc会记录并清除没有使用的内存，而在一些没有垃圾回收系统的语言中则需要我们自己对其内存的请求和释放。*
  ***RUST语言所采用的内存回收机制为当变量如果还存在于它所处的作用域中则该变量有效则不回收；当变量如果离开她的作用域以后再自动调用一个叫drop()的特殊函数对其堆上的内存进行释放***
# RUST错误处理（rust没有异常系统，不过有类似的错误处理系统；rust错误分为可恢复错误和不可恢复错误两种）
  - 可恢复错误：一般程序允许出现相应错误并根据情况再对其处理恢复的错误称为可恢复错误；类似于打开一个文件，当文件不存在时可以跳出重新打开或者告诉用户该文件不存在的提示消息，这种可恢复错误情况返回一个Result<T,E>类型。
      Result<T,E>类型：
        1)其中T泛型为成功时返回的数据类型，E为当程序发生错误时返回的Error类型。
        2)Result是一个枚举类型：成员为Ok(var)和Err(error),程序员可以使用match表达式根据返回结果设计相应的实现或操作。
        3)失败时panic的捷径： unwrap 和 expect
        - 如果 Result 值是成员 Ok ， unwrap 会返回 Ok 中的值。如果 Result 是成员 Err ， unwrap 会为我们调用 panic! 。

  - 不可恢复错误：不可恢复错误也叫BUG是指一旦程序发生错误就将终止程序向下执行，并 不可恢复只能修复该错误代码片段才能继续向下执行（类似于除0操作和数组下标越界），  在rust中不可恢复错误使用的是panic！("massage")宏。

# for循环章节
  - for 变量 in 集合{
      循环体;
    }
    - 基本Range：在Rust中循环一系列整数的最基本的方法是Range。Range由..标记产生，它生成只包含开始元素不包含结束元素并且步长为1的iterator；如果不仅需要包含开始并且还需要包含结束元素的range则需要使用...标记（两个..与三个...的区别） 。
      - for i in 1..11 {
          print!("{} ", i);
        }
        // output: 1 2 3 4 5 6 7 8 9 10
      - for i in (1..11).filter(|x| (x % 2 = 0)){
          print!("{} ", i);
          // output:  2  4  6  8 9 10
          //range支持filter()方法用于过滤筛选后的元素,filter方法使用闭包。
        }
      - for i in (1...5).rev(){
          print!("{} ", i);
          //range.rev()反转
          // output: 5 4 3 2 1
      }  